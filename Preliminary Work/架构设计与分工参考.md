# 架构设计与模块分工参考 ———— xwn 2025.7.1<br>

注：本md中存在一些存疑的设计细节等待讨论解决<br>

## Part 1 第一阶段工作目标<br>

关于第一阶段的一些设计目标<br>

* 实现所有的整数计算指令（包括加减乘除、移位、逻辑等）和分支、跳转指令，暂时不考虑load/store指令<br>
* 分支预测采用简单的两位饱和计数器或静态预测，但是要实现完整的分支预测恢复<br>
* 实现精确异常处理<br>
* 采用统一的PRF方式进行寄存器重命名、恢复、释放<br>
* 不实现背靠背的RAW处理，不添加旁路网络进行数据转发<br>
* 存储相关不做设计，不理会TLB、CSR、Cache等问题<br>

## Part 2 整体设计<br>

注：此处的信息为综合前人设计给出的预期目标<br>
pipeline: 在不考虑访存的前提下，参考前辈们的经典设计，流水线共10级（或9级？），取指令+分支预测（1-2级，未定），译码（1级），寄存器重命名（1级），分发（1级），发射（唤醒+仲裁）（1级），执行（4级？），提交+异常处理+分支预测恢复（1级）<br>
各环节重要模块（可能不全，待补充）：<br>

1. 取指令+分支预测：<br>
   PC（老样子）<br>
   BranchPredicter（暂不展开，包含Hash Unit、BHR、BHT、PHT几个模块）：此时我们只需要设计最简单的PHT即可，大小为(2^k)*2<br>
   FetchBuffer(视每周期最大取指令个数而定，理论上来说等于4)<br>
2. 译码：<br>
   Decoder(组合逻辑实现)<br>
   DecodeBuffer(同上)<br>
3. 寄存器重命名：<br>
   sRAT(大小为32行，理论上为12R4W)<br>
   aRAT(大小为32行，理论上为nR4W,且每一个单元都与sRAT点对点相连进行数据覆写，仅在指令退休时被写入，永远是正确的状态)<br>
   freelist(大小为64行，采用FIFO实现，理论上4R4W)<br>
   注：特别地，freelist同时标记了PRF的释放，这个释放机制参考《超标量处理器设计》P202，在后一条写入r1的B指令退休的同时才释放前一条A指令写入的物理寄存器，也因此freelist不需要在异常和分支预测中恢复<br>
   PRF(大小为64，理论上8R4W，注意在这种架构中计算结果存到PRF而不是ROB中，读写端口的统计是困难的。。)<br>
4. 发射（分配、唤醒、仲裁）：（machine width 和 issue width（可能大于4），发射应该是工作量最大的一部分，这几个组合逻辑电路的设计水很深，尤其是后期加入数据转发之后，有很多门道。。。）<br>
   Allocation Circuit: 从发射队列中选出四个空闲的位置塞进新的指令<br>
   Wake-up Circuit: 广播电路，把发射队列中对应指令的Ready置高<br>
   Select Circuit：根据ROB的新旧顺序挑出4条Ready的指令送进FU，此过程遵循Oldest-first原则<br>
   Issue Queue(尽量大一些，例如3\*4或4\*4等, 需要实验)<br>
   注：在发射阶段的设计中存在一些正交的选择，集中式/分布式以及数据捕捉式/非数据捕捉式，关于具体描述参见《超标量》P232，至于是否压缩的问题，我个人判断应该采用非压缩的架构，主要影响分配/仲裁电路的设计<br>
5. 执行（这部分相对信息比较少）<br>
   ALU for MUL/DIV <br>
   ALU for others<br>
   AGU (计算访存地址用的，暂不实现)<br>
   BRU (判断分支预测是否正确)<br>
6. 提交+异常处理+分支预测恢复<br>
   ROB(至少为12R8W，指令在分发阶段进入ROB，且ROB序号在整个流水线中伴随着指令一起流动)<br>
   包含内容一览：<br>
   Complete||Areg||Preg||OPreg||PC||Exception||Type<br>
   注：需要考虑每周期指令退休的限制，这涉及到BranchPredicter等单元的读写端口需求<br>

## Part 3 分工参考与第二阶段预想<br>

建议：根据上述六个部分进行分工<br>
预想：实现完整的分支预测算法，并加入访存指令<br>
